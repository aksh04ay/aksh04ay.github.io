<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="keywords" content="akshay, kumar, iit, iitk, cse, aksh04ay, akshay kumar, iit kanpur, iitk.ac.in, cse.iitk.ac.in">
<meta name="description" content="Akshay Kumar, CSE, IIT Kanpur">
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<link rel="stylesheet" href="ugc.css" type="text/css" />
<title>kakshay ~ cse@iitk</title>
</head>
<body>
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-category">academics</div>
<div class="menu-item"><a href="index.html">Home</a></div>
<div class="menu-item"><a href="academics.html">Academics</a></div>
<div class="menu-item"><a href="publications.html">Publications</a></div>
<div class="menu-item"><a href="talks.html">Talks&nbsp;Given</a></div>
<div class="menu-item"><a href="courses.html">Course&nbsp;Work</a></div>
<div class="menu-item"><a href="achievements.html">Achievements</a></div>
<div class="menu-item"><a href="docs/AkshayKumar_Resume.pdf">Resume</a></div>
<div class="menu-category">projects</div>
<div class="menu-item"><a href="researchintern.html">Research&nbsp;Internships</a></div>
<div class="menu-item"><a href="softwareintern.html">Software&nbsp;Internship</a></div>
<div class="menu-item"><a href="researchexp.html">Research&nbsp;Experience</a></div>
<div class="menu-item"><a href="selectproject.html">Select&nbsp;Projects</a></div>
<div class="menu-category">others</div>
<div class="menu-item"><a href="extracurrics.html">Extracurrics</a></div>
<div class="menu-item"><a href="contact.html">Contact</a></div>
<div class="menu-category">technical writings</div>
<div class="menu-item"><a href="mmw.html">MMW</a></div>
<div class="menu-item"><a href="ugc.html" class="current">UGC</a></div>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>Unique Games Conjecture</h1>
</div>
<p>Very recently, <a href="https://www.cs.nyu.edu/~khot/">Subhash Khot</a> <a href="http://www.simonsfoundation.org/quanta/20140812-a-grand-vision-for-the-impossible/">won</a> the <a href="https://en.wikipedia.org/wiki/Nevanlinna_Prize">Rolf Nevanlinna Prize</a>, considered one of the top honours in the field of mathematics, for his contribution to computational complexity theory. The conjecture has broad applications in the theory of hardness of approximations and is unusual in the sense that unlike <img class="eq" src="eqs/1092789785-130.png" alt="textup{P} stackrel{?}{=} textup{NP}" style="vertical-align: -3px" /> problem, the academic world seems evenly divided on whether this conjecture is true or not.</p>
<div class="infoblock">
<div class="blockcontent">
<p>&ldquo;Some very natural, intrinsically interesting statements about things like voting and foams just popped out of studying the UGC&hellip;. Even if the UGC turns out to be false, it has inspired a lot of interesting math research.&rdquo;</p>
<p>—Ryan O’Donnell</p>
</div></div>
<p>This post is very basic and targeted towards anyone who has a knowledge of what complexity classes <img class="eq" src="eqs/1427970786-130.png" alt="textup{P}" style="vertical-align: -0px" />, <img class="eq" src="eqs/1298269799-130.png" alt="textup{NP}" style="vertical-align: -0px" />, <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Hard and <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Complete means.</p>
<p>Assuming <img class="eq" src="eqs/633332575-130.png" alt="textup{P} neq textup{NP}" style="vertical-align: -4px" />, researchers started exploring footholds for finding near optimal solutions efficiently. However, as it turns out, for some <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Complete optimization, it is not possible to approximate beyond a particular factor. Perhaps an example will highlight point.</p>
<h2>Approximation Algorithms</h2>
<p>Any <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />optimization, <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" />, is either a minimization or a maximization problem. For a minimization problem, for each instance <img class="eq" src="eqs/754093512-130.png" alt="I" style="vertical-align: -0px" /> of <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" /> , there exists a non-empty feasible set of solutions each of which is assigned an objective value. Our goal is to come up with the one whose objective value is lowest. Let's us call such a solution as optimal solution and let's denote it value by <img class="eq" src="eqs/900988662-130.png" alt="textup{OPT}(I)" style="vertical-align: -5px" />. We wish to come up with a solution which is as close (but greater since <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" /> is a minimization problem) to <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" /> as possible. Suppose, an approximation algorithm <img class="eq" src="eqs/1600353188-130.png" alt="mathcal{A}" style="vertical-align: -1px" /> outputs a solution which at most <img class="eq" src="eqs/1718774046-130.png" alt="alpha" style="vertical-align: -1px" /> times <img class="eq" src="eqs/900988662-130.png" alt="textup{OPT}(I)" style="vertical-align: -5px" /> (<img class="eq" src="eqs/1554438227-130.png" alt="alpha &gt; 1" style="vertical-align: -1px" />). We say that <img class="eq" src="eqs/1600353188-130.png" alt="mathcal{A}" style="vertical-align: -1px" /> is a <img class="eq" src="eqs/2003939682-130.png" alt="alpha-" style="vertical-align: -1px" />factor approximation algorithm. Similar results hold for maximization problems as well.
We will now prove the hardnes for TSP.</p>
<h3>Example: Travelling Salesman Problem (TSP)</h3>
<p>We will show that it is hard to approximate TSP for any approximation factor. To prove this, we will transform Hamiltonian Cycle Problem to TSP.</p>
<div class="infoblock">
<div class="blockcontent">
<p><b>TSP</b>: Given a weighted undirected graph, find the minimum weight tour that visits each vertex exactly once.<br />
<b>Hamiltonian Cycle Problem</b>: Given a Graph <img class="eq" src="eqs/498092742-130.png" alt="G" style="vertical-align: -1px" />, does there exist a simple cycle that visits all the vertices of <img class="eq" src="eqs/498092742-130.png" alt="G" style="vertical-align: -1px" /> exactly once?</p>
</div></div>
<p>Given an instance <img class="eq" src="eqs/498092742-130.png" alt="G" style="vertical-align: -1px" /> of Hamiltonian Cycle Problem, construct an instance <img class="eq" src="eqs/626093129-130.png" alt="H" style="vertical-align: -0px" /> of TSP as follows:</p>
<ol>
<li><p><img class="eq" src="eqs/1944726487-130.png" alt="V(H) = V(G)" style="vertical-align: -5px" />.</p>
</li>
<li><p><img class="eq" src="eqs/626093129-130.png" alt="H" style="vertical-align: -0px" /> is a complete graph.</p>
</li>
<li><p>For all edges <img class="eq" src="eqs/1860647573-130.png" alt="e in E(G)" style="vertical-align: -5px" />, <img class="eq" src="eqs/1909400738-130.png" alt="w_e(H)=1" style="vertical-align: -5px" />.</p>
</li>
<li><p>For other edges, <img class="eq" src="eqs/1503663764-130.png" alt="w_e(H)=alpha n" style="vertical-align: -5px" /> where <img class="eq" src="eqs/1147221343-130.png" alt="n=|V(G)|" style="vertical-align: -5px" />.</p>
</li>
</ol>
<p>If <img class="eq" src="eqs/498092742-130.png" alt="G" style="vertical-align: -1px" /> has a hamiltonian cycle, <img class="eq" src="eqs/991789946-130.png" alt="textup{OPT}(H)=n" style="vertical-align: -5px" />. Otherwise, the tour must include an edge of weight <img class="eq" src="eqs/141148578-130.png" alt="alpha n" style="vertical-align: -1px" />. Hence, <img class="eq" src="eqs/607923520-130.png" alt="textup{OPT}(H) &gt; alpha n" style="vertical-align: -5px" />.</p>
<p>If there is a <img class="eq" src="eqs/2003939682-130.png" alt="alpha-" style="vertical-align: -1px" />factor approximation factor for TSP, we can reduce Hamiltonian Cycle Problem to TSP and check the decidability of Hamiltonian Cycle Problem. If <img class="eq" src="eqs/498092742-130.png" alt="G" style="vertical-align: -1px" /> has a hamiltonian cycle, <img class="eq" src="eqs/991789946-130.png" alt="textup{OPT}(H)=n" style="vertical-align: -5px" />. Hence, the algorithm outputs a tour of weight at most <img class="eq" src="eqs/141148578-130.png" alt="alpha n" style="vertical-align: -1px" />. Otherwise, <img class="eq" src="eqs/607923520-130.png" alt="textup{OPT}(H) &gt; alpha n" style="vertical-align: -5px" /> which implies the tour the algorithm outputs has weight greater than <img class="eq" src="eqs/141148578-130.png" alt="alpha n" style="vertical-align: -1px" />. This creates a gap between the YES/NO instances of Hamiltonian Cycle Problem and it's decidability can be checked efficiently, which is not possible. Hence, it's hard to approximate TSP to a factor of <img class="eq" src="eqs/1718774046-130.png" alt="alpha" style="vertical-align: -1px" />, for any <img class="eq" src="eqs/1718774046-130.png" alt="alpha" style="vertical-align: -1px" />.</p>
<h2>Reduction</h2>
<p>Let <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" /> be a minimization problem. A gap-introducing reduction maps an instance <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> of <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a> to a instance <img class="eq" src="eqs/1819822983-130.png" alt="x" style="vertical-align: -1px" /> of <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" /> such that</p>
<ul>
<li><p>If <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> is satisfiable, then <img class="eq" src="eqs/2146456374-130.png" alt="textup{OPT}(x) le f(x)" style="vertical-align: -5px" />, and</p>
</li>
<li><p>If <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> is not satisfiable, then <img class="eq" src="eqs/1212326370-130.png" alt="textup{OPT}(x) &gt; alpha f(x)" style="vertical-align: -5px" />.</p>
</li>
</ul>
<p>Obviously, <img class="eq" src="eqs/1221200505-130.png" alt="alpha ge 1" style="vertical-align: -3px" />. Such a kind of gap-introducing reduction immediately implies an inapproximability of <img class="eq" src="eqs/1718774046-130.png" alt="alpha" style="vertical-align: -1px" /> for <img class="eq" src="eqs/2120508326-130.png" alt="Pi" style="vertical-align: -0px" />.</p>
<p>One problem with the above approach is blowing an &ldquo;additive&rdquo; gap to a &ldquo;multiplicative&rdquo; gap.</p>
<h2>PCP Theorem</h2>
<p>Probabilistic characterization of <img class="eq" src="eqs/1298269799-130.png" alt="textup{NP}" style="vertical-align: -0px" /> class yields a general technique for gap-introducing reduction. Informally speaking, a probabilistically checkable proof for an <img class="eq" src="eqs/1298269799-130.png" alt="textup{NP}" style="vertical-align: -0px" /> language is a proof whose validity can be checked probabilistically by examining its very few bits. A probabilistically checkable proof system comes with two parameters: <b>(a)</b> <img class="eq" src="eqs/138320448-130.png" alt="r(n):" style="vertical-align: -5px" /> the number of random bits required by the verifier, and <b>(b)</b> <img class="eq" src="eqs/598968483-130.png" alt="q(n):" style="vertical-align: -5px" /> the number of bits of the proof the verifier is allowed to examine.</p>
<p>A language <img class="eq" src="eqs/423916817-130.png" alt="L in textup{PCP}(r(n),q(n))" style="vertical-align: -5px" /> if there's a verifier <img class="eq" src="eqs/1876868777-130.png" alt="V" style="vertical-align: -1px" /> that on input <img class="eq" src="eqs/1819822983-130.png" alt="x" style="vertical-align: -1px" />, obtains a random string of length <img class="eq" src="eqs/2041444916-130.png" alt="c cdot r(|x|)" style="vertical-align: -5px" /> and queries <img class="eq" src="eqs/1919733704-130.png" alt="d cdot q(|x|)" style="vertical-align: -5px" /> bits of the proof such that (<img class="eq" src="eqs/212863774-130.png" alt="c" style="vertical-align: -1px" /> & <img class="eq" src="eqs/84863387-130.png" alt="d" style="vertical-align: -1px" /> are constants):</p>
<ul>
<li><p>If <img class="eq" src="eqs/183609310-130.png" alt="x in L" style="vertical-align: -1px" />, then there's a proof which verifier accepts with probability <img class="eq" src="eqs/1977051568-130.png" alt="1" style="vertical-align: -0px" />, and</p>
</li>
<li><p>If <img class="eq" src="eqs/599043572-130.png" alt="x notin L" style="vertical-align: -5px" />, then every proof is accepted with probability <img class="eq" src="eqs/920638062-130.png" alt="&lt; frac{1}{2}" style="vertical-align: -7px" />.</p>
</li>
</ul>
<p>The PCP Theorem gives another characterization of the class <img class="eq" src="eqs/1298269799-130.png" alt="textup{NP}" style="vertical-align: -0px" />.</p>
<div class="infoblock">
<div class="blockcontent">
<p><b>PCP Theorem:</b> <img class="eq" src="eqs/471820746-130.png" alt="textup{NP}=textup{PCP}(log n,1)" style="vertical-align: -5px" /></p>
</div></div>
<p>One direction of the proof, <img class="eq" src="eqs/228927879-130.png" alt="textup{NP} subseteq textup{PCP}(log n,1)" style="vertical-align: -5px" /> is easy (try proving it as a small exercise). Other direction has been a result of years of research by various CS Theorists. For an excellent exposition to the history of PCP Theorem, refer <a href="http://courses.cs.washington.edu/courses/cse533/05au/pcp-history.pdf">here</a>. Fortunately, the theorem, modulo its proof, is sufficient to derive hardness results.</p>
<h3>Hardness of <a href="http://en.wikipedia.org/wiki/MAX-3SAT">MAX-3SAT</a></h3>
<p>In this example, we will try proving the hardness for <img class="eq" src="eqs/1018987277-130.png" alt="textup{MAX-3SAT}" style="vertical-align: -1px" />. The reduction is from <img class="eq" src="eqs/773289680-130.png" alt="textup{3SAT}" style="vertical-align: -1px" />. Specifically, there exists a constant <img class="eq" src="eqs/223148832-130.png" alt="alpha^*" style="vertical-align: -1px" /> such that a <img class="eq" src="eqs/773289680-130.png" alt="textup{3SAT}" style="vertical-align: -1px" /> formula <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> can be converted to a <img class="eq" src="eqs/1018987277-130.png" alt="textup{MAX-3SAT}" style="vertical-align: -1px" /> formula <img class="eq" src="eqs/1913821872-130.png" alt="psi" style="vertical-align: -4px" /> such that</p>
<ul>
<li><p>If <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> is satisfiable, then <img class="eq" src="eqs/1950661422-130.png" alt="textup{OPT}(psi)=1" style="vertical-align: -5px" />, and</p>
</li>
<li><p>If <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> is not satisfiable, then <img class="eq" src="eqs/1734486953-130.png" alt="textup{OPT}(psi) &lt; alpha^*" style="vertical-align: -5px" />.</p>
</li>
</ul>
<p>The PCP for <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> consists of a truth assignment to its boolean variables. The essential idea of the reduction is to encode the probabilistically checkable proof as a <img class="eq" src="eqs/1018987277-130.png" alt="textup{MAX-3SAT}" style="vertical-align: -1px" /> instance. The verifier uses <img class="eq" src="eqs/455891077-130.png" alt="c log n" style="vertical-align: -4px" /> random bits and queries <img class="eq" src="eqs/1579141616-130.png" alt="q" style="vertical-align: -4px" /> bits of the proof. In all, there can be <img class="eq" src="eqs/1404124196-130.png" alt="n^c" style="vertical-align: -1px" /> different possible random strings generated and hence a total of <img class="eq" src="eqs/723863396-130.png" alt="qn^c" style="vertical-align: -4px" /> locations of the proof can be queried by the verifier. <img class="eq" src="eqs/1913821872-130.png" alt="psi" style="vertical-align: -4px" /> will have a variable corresponding to each of these locations.</p>
<p>A random string <img class="eq" src="eqs/1707142003-130.png" alt="r" style="vertical-align: -1px" /> picked by the verifier gives us a value either True or False based on the values of the variables in those <img class="eq" src="eqs/1579141616-130.png" alt="q" style="vertical-align: -4px" /> locations. This truth value can be represented as a function <img class="eq" src="eqs/894455712-130.png" alt="f_r : {0,1}^q to {0,1}" style="vertical-align: -5px" />. Hence, we can define a <img class="eq" src="eqs/773289680-130.png" alt="textup{3SAT}" style="vertical-align: -1px" /> boolean formula <img class="eq" src="eqs/992495357-130.png" alt="psi_r" style="vertical-align: -4px" /> as follows: for all <img class="eq" src="eqs/686213738-130.png" alt="(v_1,dots,v_q)" style="vertical-align: -6px" /> such that <img class="eq" src="eqs/1741762130-130.png" alt="f(v_1,dots,v_q)=0" style="vertical-align: -6px" />, add a clause <img class="eq" src="eqs/1249939097-130.png" alt="g(u_1) lor dots lor g(u_q)" style="vertical-align: -6px" /> where <img class="eq" src="eqs/1282519845-130.png" alt="u_1,dots,u_q" style="vertical-align: -6px" /> are the corresponding variables and <img class="eq" src="eqs/300242276-130.png" alt="g(u_i)=bar{u_i}" style="vertical-align: -5px" /> if <img class="eq" src="eqs/1783470783-130.png" alt="v_i=1" style="vertical-align: -4px" /> and <img class="eq" src="eqs/1849051185-130.png" alt="0" style="vertical-align: -1px" /> otherwise. Then can at most be <img class="eq" src="eqs/1344595798-130.png" alt="2^q" style="vertical-align: -0px" /> clauses in <img class="eq" src="eqs/992495357-130.png" alt="psi_r" style="vertical-align: -4px" />. Also, the length of each clause is <img class="eq" src="eqs/1579141616-130.png" alt="q" style="vertical-align: -4px" />. Ensure that the length of each clause is <img class="eq" src="eqs/2061914958-130.png" alt="3" style="vertical-align: -1px" /> by adding <img class="eq" src="eqs/1701576715-130.png" alt="q-2" style="vertical-align: -4px" /> new variables to each clause. The maximum number of clauses now is <img class="eq" src="eqs/1258583618-130.png" alt="q2^q" style="vertical-align: -4px" />.</p>
<p><img class="eq" src="eqs/2101718128-130.png" alt="psi := cap_r psi_r" style="vertical-align: -4px" />. <img class="eq" src="eqs/1913821872-130.png" alt="psi" style="vertical-align: -4px" /> has at most <img class="eq" src="eqs/813670270-130.png" alt="n^cq2^q" style="vertical-align: -4px" /> clauses. If <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> is satisfiable, all the clauses of <img class="eq" src="eqs/1913821872-130.png" alt="psi" style="vertical-align: -4px" /> is true. However, if <img class="eq" src="eqs/1886821793-130.png" alt="phi" style="vertical-align: -4px" /> is not satisfiable, at least half the random string rejects the proof <i>i.e.</i> at least half of <img class="eq" src="eqs/992495357-130.png" alt="psi_r" style="vertical-align: -4px" /> are not satisfiable. Hence, number of unsatisfiable clauses in <img class="eq" src="eqs/1913821872-130.png" alt="psi" style="vertical-align: -4px" /> must be at least <img class="eq" src="eqs/277284065-130.png" alt="n^c/2" style="vertical-align: -5px" />. Hence, <img class="eq" src="eqs/1298117731-130.png" alt="textup{OPT}(psi) &lt; 1/q2^{q+1}" style="vertical-align: -5px" />.</p>
<p>PCP Theorem was a landmark result in the field of computational complexity and after its inception, the focus moved on to produce optimal results <i>i.e.</i> to prove approximability and inaproximability results for a problem that match each other. The most influential development consisted of <img class="eq" src="eqs/1345578110-130.png" alt="textup{Label Cover problem}" style="vertical-align: -4px" /> (a.k.a. <img class="eq" src="eqs/1972490346-130.png" alt="textup{2-Prover-1-Round Game}" style="vertical-align: -1px" />), Raz's Parallel Repetition Theorem, introduction of Long Code, its application in analyzing PCPs, and Hastad's use of Fourier Series to analyze Long Code. I will briefly mention about these results.</p>
<h2>Label Cover Problem (a.k.a. 2-Prover-1-Round Game)</h2>
<p>A <img class="eq" src="eqs/1583447351-130.png" alt="textup{2-Prover-1-Round Game } mathcal{U}_{2p1r}(G(V,W,E),[m],[n],{pi_e|e in E})" style="vertical-align: -6px" /> is a <a href="http://en.wikipedia.org/wiki/Constraint_satisfaction_problem">CSP</a>.
It consists of a bipartite graph <img class="eq" src="eqs/604905560-130.png" alt="G(V,W,E)" style="vertical-align: -5px" /> where vertices represent variables and edges represent constraints. Goal is to find a labelling <img class="eq" src="eqs/79312034-130.png" alt="L : V to [m], W to [n]" style="vertical-align: -5px" /> such that for all edges <img class="eq" src="eqs/1229992264-130.png" alt="e=(u,w) in E" style="vertical-align: -5px" />, the following &ldquo;projection&rdquo; constraint is satisfied: <img class="eq" src="eqs/1302202643-130.png" alt="pi_e(L(u))=L(w)" style="vertical-align: -5px" />. Let <img class="eq" src="eqs/1066280275-130.png" alt="textup{OPT}(mathcal{U}_{2p1r})" style="vertical-align: -6px" /> denote its optimal value.</p>

<div class="eqwl"><img class="eqwl" src="eqs/1460817759-130.png" alt=" textup{OPT}(mathcal{U}_{2p1r}) := max_{L:V to [m], W to [n]} frac{1}{|E|} cdot |{e in E ~ | ~ L  satisfies  e}| " />
<br /></div><p>I will now give the <i>game</i> formulation of <img class="eq" src="eqs/1816955271-130.png" alt="textup{2-Prover-1-Round Game}:" style="vertical-align: -1px" /> Given an instance <img class="eq" src="eqs/1874723273-130.png" alt="mathcal{U}_{2p1r}" style="vertical-align: -6px" />, consider a probabilistic verifier <img class="eq" src="eqs/1876868777-130.png" alt="V" style="vertical-align: -1px" /> which picks an edge <img class="eq" src="eqs/315524061-130.png" alt="e=(v,w) in E" style="vertical-align: -5px" /> at random and sends <img class="eq" src="eqs/2075823753-130.png" alt="v" style="vertical-align: -1px" /> to Prover <img class="eq" src="eqs/492969155-130.png" alt="P1" style="vertical-align: -0px" /> and <img class="eq" src="eqs/1947823370-130.png" alt="w" style="vertical-align: -1px" /> to Prover <img class="eq" src="eqs/492969152-130.png" alt="P2" style="vertical-align: -0px" />. The provers respond back with labels from set <img class="eq" src="eqs/1048607978-130.png" alt="[m]" style="vertical-align: -5px" /> and <img class="eq" src="eqs/1051607843-130.png" alt="[n]" style="vertical-align: -5px" /> respectively. The Verifier accepts only if <img class="eq" src="eqs/451342734-130.png" alt="pi_e(i)=j" style="vertical-align: -5px" /> where <img class="eq" src="eqs/555138536-130.png" alt="i" style="vertical-align: -1px" /> and <img class="eq" src="eqs/683138923-130.png" alt="j" style="vertical-align: -4px" /> are the labels returned. The provers&rsquo; strategy is to maximize the probability of acceptance. The probability, called the <i>value</i> of the game, will obviously be same as <img class="eq" src="eqs/1066280275-130.png" alt="textup{OPT}(mathcal{U}_{2p1r})" style="vertical-align: -6px" />. This establishes the analogue between Constraint Satisfaction View and the <img class="eq" src="eqs/308105785-130.png" alt="2-" style="vertical-align: -0px" />Prover<img class="eq" src="eqs/2067129652-130.png" alt="-1-" style="vertical-align: -0px" />Round view.</p>
<p>We are interested in the case when the label sets <img class="eq" src="eqs/1048607978-130.png" alt="[m]" style="vertical-align: -5px" /> and <img class="eq" src="eqs/1051607843-130.png" alt="[n]" style="vertical-align: -5px" /> have constant sizes. The PCP Theorem implies that the gap version of <img class="eq" src="eqs/1874723273-130.png" alt="mathcal{U}_{2p1r}" style="vertical-align: -6px" /> is <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Hard and this gap can be amplified using Raz's Parallel Repetition Theorem.</p>
<h2>PCP Theorem + Raz's Parallel Repetition Theorem</h2>
<p>For every <img class="eq" src="eqs/885564590-130.png" alt="delta &gt; 0" style="vertical-align: -1px" />, <img class="eq" src="eqs/742012884-130.png" alt="textup{Gap2P1R}_{1,delta}" style="vertical-align: -8px" /> is <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Hard for instances with label cover of size <img class="eq" src="eqs/60773019-130.png" alt="poly(1/delta)" style="vertical-align: -5px" />. Specifically, there exists a constance <img class="eq" src="eqs/13908798-130.png" alt="C" style="vertical-align: -1px" /> such that for every <img class="eq" src="eqs/416838492-130.png" alt="delta&gt;0" style="vertical-align: -1px" />, <img class="eq" src="eqs/944909513-130.png" alt="mathcal{U}_{2p1r}(G(V,W,E),[m],[n],{pi_e|e in E})" style="vertical-align: -6px" />, <img class="eq" src="eqs/76802846-130.png" alt="m=(1/delta)^C" style="vertical-align: -5px" />, it is <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Hard to distinguish between:</p>
<ul>
<li><p><img class="eq" src="eqs/997192582-130.png" alt="YES" style="vertical-align: -1px" /> case: <img class="eq" src="eqs/353894480-130.png" alt="textup{textup{OPT}}(mathcal{U}_{2p1r})=1" style="vertical-align: -6px" />.</p>
</li>
<li><p><img class="eq" src="eqs/480644903-130.png" alt="NO" style="vertical-align: -1px" /> case: <img class="eq" src="eqs/633429953-130.png" alt="textup{textup{OPT}}(mathcal{U}_{2p1r})&lt;delta" style="vertical-align: -6px" />.</p>
</li>
</ul>
<p>Many inapproximability results are obtained by reduction from <img class="eq" src="eqs/742012884-130.png" alt="textup{Gap2P1R}_{1,delta}" style="vertical-align: -8px" />.</p>
<p>The inapproximability results derived from <img class="eq" src="eqs/809606137-130.png" alt="textup{Unique Games}" style="vertical-align: -4px" /> often use gadgets constructed from Boolean hypercube. These reductions can be viewed as PCPs and the gadgets test, probabilistically, whether a given codeword is a <i>Long Code</i> or not. A useful Long Code-ing scheme is the so called <i>dictatorship</i> function on a boolean hypercube - it's a function <img class="eq" src="eqs/1348084858-130.png" alt="f:{-1,1}^n to {-1,1}" style="vertical-align: -5px" /> that depends only on one coordinate <i>i.e.</i> <img class="eq" src="eqs/2024601251-130.png" alt="f(mathbf{x})=x_i" style="vertical-align: -5px" /> for some fixed <img class="eq" src="eqs/555138536-130.png" alt="i" style="vertical-align: -1px" />. The truth table for this function can be thought of as an encoding scheme for <img class="eq" src="eqs/555138536-130.png" alt="i" style="vertical-align: -1px" />. We need that a dictatorship function passes this test with probability <img class="eq" src="eqs/1308687462-130.png" alt="ge c" style="vertical-align: -3px" /> whereas a function that is <i>far from bring a dictatorship function</i> passes this test with probability at most <img class="eq" src="eqs/1835142386-130.png" alt="s" style="vertical-align: -1px" />. This gap <img class="eq" src="eqs/467875106-130.png" alt="c/s" style="vertical-align: -5px" /> essentially translates to a <img class="eq" src="eqs/1692253197-130.png" alt="textup{Gap}mathcal{I}_{c,s}" style="vertical-align: -6px" /> instance of <img class="eq" src="eqs/1608353180-130.png" alt="mathcal{I}" style="vertical-align: -0px" />.</p>
<p>The PCP replaces every vertex of <img class="eq" src="eqs/1972490346-130.png" alt="textup{2-Prover-1-Round Game}" style="vertical-align: -1px" /> with a boolean hypercube: for <img class="eq" src="eqs/944909513-130.png" alt="mathcal{U}_{2p1r}(G(V,W,E),[m],[n],{pi_e|e in E})" style="vertical-align: -6px" />, every <img class="eq" src="eqs/397856446-130.png" alt="v in V" style="vertical-align: -1px" /> is replaced by a <img class="eq" src="eqs/1475813080-130.png" alt="m-" style="vertical-align: -1px" />dimensional hypercube and every <img class="eq" src="eqs/398327554-130.png" alt="w in W" style="vertical-align: -1px" /> is replaced by a <img class="eq" src="eqs/677832677-130.png" alt="n-" style="vertical-align: -1px" />dimensional hypercube. The PCP consists of truth table of boolean functions on these hypercubes. PCP testing consits of two parts:</p>
<ol>
<li><p><b>Codeword Testing:</b> Each boolean function is close to a dictatorship function, and</p>
</li>
<li><p><b>Consistency Testing:</b> For an edge <img class="eq" src="eqs/315524061-130.png" alt="e=(v,w) in E" style="vertical-align: -5px" />, <img class="eq" src="eqs/451342734-130.png" alt="pi_e(i)=j" style="vertical-align: -5px" />, where <img class="eq" src="eqs/555138536-130.png" alt="i" style="vertical-align: -1px" /> and <img class="eq" src="eqs/683138923-130.png" alt="j" style="vertical-align: -4px" /> are the labels which the dictatorship function on boolean hypercubes for vertex <img class="eq" src="eqs/2075823753-130.png" alt="v" style="vertical-align: -1px" /> and (respectively) <img class="eq" src="eqs/1947823370-130.png" alt="w" style="vertical-align: -1px" /> correspond to.</p>
</li>
</ol>
<h2>Unique Games Conjecture</h2>
<p>The PCP strategy described above succeeds for some problems (<a href="https://en.wikipedia.org/wiki/MAX-3SAT"><img class="eq" src="eqs/1018987277-130.png" alt="textup{MAX-3SAT}" style="vertical-align: -1px" /></a>, <a href="https://en.wikipedia.org/wiki/Clique_problem"><img class="eq" src="eqs/1409613550-130.png" alt="textup{Clique}" style="vertical-align: -4px" /></a>, <a href="https://en.wikipedia.org/wiki/Hypergraph#Hypergraph_coloring"><img class="eq" src="eqs/688174113-130.png" alt="textup{Hypergraph Coloring}" style="vertical-align: -4px" /></a>), it doesn't yield any useful results for problems such as <a href="https://en.wikipedia.org/wiki/Vertex_cover"><img class="eq" src="eqs/775025050-130.png" alt="textup{Vertex Cover}" style="vertical-align: -1px" /></a>, <a href="https://en.wikipedia.org/wiki/Maximum_cut"><img class="eq" src="eqs/875782537-130.png" alt="textup{MaxCut}" style="vertical-align: -1px" /></a>, <a href="https://en.wikipedia.org/wiki/2-satisfiability#Maximum-2-satisfiability"><img class="eq" src="eqs/1703928460-130.png" alt="textup{Min-2SAT-Deletion}" style="vertical-align: -1px" /></a>, and <a href="https://en.wikipedia.org/wiki/Graph_coloring"><img class="eq" src="eqs/488454248-130.png" alt="textup{Graph Coloring}" style="vertical-align: -4px" /></a>. For the first set of problems, PCPs are allowed to make three or more queries but for the second set of problems, at most two queries are allowed, which makes the PCP very weak.</p>
<p>It was pointed out that another barrier is the &ldquo;many-to-one&rdquo;-ness of the projection constraints <img class="eq" src="eqs/462312592-130.png" alt="pi_e" style="vertical-align: -4px" /> in <img class="eq" src="eqs/1972490346-130.png" alt="textup{2-Prover-1-Round Game}" style="vertical-align: -1px" />, <i>i.e.</i>, when <img class="eq" src="eqs/26715642-130.png" alt="frac{m}{n} to infty" style="vertical-align: -8px" />. This poses a problem in the consistency testing part where a <img class="eq" src="eqs/2105051955-130.png" alt="2" style="vertical-align: -0px" /> query PCP is too weak to ensure consistency between two hypercubes of vastly varying dimensions. This motivated the study of <img class="eq" src="eqs/809606137-130.png" alt="textup{Unique Games}" style="vertical-align: -4px" /> where <img class="eq" src="eqs/1992943171-130.png" alt="m=n" style="vertical-align: -1px" /> and <img class="eq" src="eqs/235770543-130.png" alt="pi_e: [m] to [n]" style="vertical-align: -5px" /> is a bijection.</p>
<h3>Unique Game</h3>
<p>A <img class="eq" src="eqs/15581311-130.png" alt="textup{Unique Game}" style="vertical-align: -4px" /> <img class="eq" src="eqs/928276288-130.png" alt="mathcal{U}(G(V,E),[n],{pi_e|e in E})" style="vertical-align: -5px" /> is a constraint satisfaction problem: given a directed graph <img class="eq" src="eqs/1681145303-130.png" alt="G(V,E)" style="vertical-align: -5px" /> where vertices represent variables and edges represent constraint, the objective is to assign a label to each vertex from the set <img class="eq" src="eqs/1051607843-130.png" alt="[n]" style="vertical-align: -5px" /> such that maximum number of edges are satisfied. The constraint on each edge <img class="eq" src="eqs/43136996-130.png" alt="e" style="vertical-align: -1px" /> is a bijection <img class="eq" src="eqs/88705947-130.png" alt="pi_e:[n] to [n]" style="vertical-align: -5px" />. An edge <img class="eq" src="eqs/2120929667-130.png" alt="e=(v,w)" style="vertical-align: -5px" /> is satisfied by a labelling <img class="eq" src="eqs/1246299647-130.png" alt="L:V to[n]" style="vertical-align: -5px" /> if <img class="eq" src="eqs/802398602-130.png" alt="pi_e(L(v))=L(w)" style="vertical-align: -5px" />.</p>

<div class="eqwl"><img class="eqwl" src="eqs/410258350-130.png" alt=" textup{OPT}(mathcal{U}) := max_{L:V to [n]} frac{1}{|E|} cdot |{e in E ~ | ~ L  satisfies  e}| " />
<br /></div><p>As opposed to <img class="eq" src="eqs/1972490346-130.png" alt="textup{2-Prover-1-Round Game}" style="vertical-align: -1px" />, the graph here need not be bipartite. This distinction is minor as can be seen by the following <i>game</i> formulaion of <img class="eq" src="eqs/15581311-130.png" alt="textup{Unique Game}" style="vertical-align: -4px" />: given an instance <img class="eq" src="eqs/928276288-130.png" alt="mathcal{U}(G(V,E),[n],{pi_e|e in E})" style="vertical-align: -5px" /> of <img class="eq" src="eqs/15581311-130.png" alt="textup{Unique Game}" style="vertical-align: -4px" /> problem, the verifier picks an edge <img class="eq" src="eqs/562291973-130.png" alt="e=(u,v) in E" style="vertical-align: -5px" /> at random and sends <img class="eq" src="eqs/2091143156-130.png" alt="u" style="vertical-align: -1px" /> to prover <img class="eq" src="eqs/1437360129-130.png" alt="P_1" style="vertical-align: -3px" /> and <img class="eq" src="eqs/2075823753-130.png" alt="v" style="vertical-align: -1px" /> to prover <img class="eq" src="eqs/1437360132-130.png" alt="P_2" style="vertical-align: -3px" />. <img class="eq" src="eqs/1437360129-130.png" alt="P_1" style="vertical-align: -3px" /> & <img class="eq" src="eqs/1437360132-130.png" alt="P_2" style="vertical-align: -3px" /> returns a label in <img class="eq" src="eqs/1051607843-130.png" alt="[n]" style="vertical-align: -5px" /> and the verifier acceptes only if <img class="eq" src="eqs/451342734-130.png" alt="pi_e(i)=j" style="vertical-align: -5px" /> where <img class="eq" src="eqs/555138536-130.png" alt="i" style="vertical-align: -1px" /> & <img class="eq" src="eqs/683138923-130.png" alt="j" style="vertical-align: -4px" /> are the answers of two provers.</p>
<p>Note that if <img class="eq" src="eqs/1349875658-130.png" alt="textup{OPT}(mathcal{U})=1" style="vertical-align: -5px" />, then such a labelling can be found in polynomial time: fixing the label of a vertex automatically fixes the label of every vertex which is its neighbour and so on. From the viewpoint of <img class="eq" src="eqs/1604005972-130.png" alt="textup{Unique Games Conjecture}" style="vertical-align: -4px" />, the interesting case is when <img class="eq" src="eqs/1191198368-130.png" alt="textup{OPT}(mathcal{U})=1-epsilon" style="vertical-align: -5px" /> where <img class="eq" src="eqs/1460515730-130.png" alt="epsilon&gt;0" style="vertical-align: -1px" />.</p>
<h3>Unique Game Conjecture</h3>
<div class="infoblock">
<div class="blockcontent">
<p><b>Unique Games Conjecture</b>: <img class="eq" src="eqs/139160827-130.png" alt="textup{GAP}mathcal{U}_{1-epsilon,delta}" style="vertical-align: -6px" /> is <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Hard</p>
</div></div>
<p>For every <img class="eq" src="eqs/1716531829-130.png" alt="epsilon,delta&gt;0" style="vertical-align: -4px" />, there exists a <img class="eq" src="eqs/2103924492-130.png" alt="n=n(epsilon,delta)" style="vertical-align: -5px" />, such that given a <img class="eq" src="eqs/15581311-130.png" alt="textup{Unique Game}" style="vertical-align: -4px" /> instance <img class="eq" src="eqs/928276288-130.png" alt="mathcal{U}(G(V,E),[n],{pi_e|e in E})" style="vertical-align: -5px" />, it is <img class="eq" src="eqs/425490843-130.png" alt="textup{NP}-" style="vertical-align: -0px" />Hard to distinguish between the two cases:</p>
<ul>
<li><p><img class="eq" src="eqs/997192582-130.png" alt="YES" style="vertical-align: -1px" /> case: <img class="eq" src="eqs/392692181-130.png" alt="textup{OPT}(mathcal{U}) ge 1 - epsilon" style="vertical-align: -5px" />.</p>
</li>
<li><p><img class="eq" src="eqs/480644920-130.png" alt="NP" style="vertical-align: -0px" /> case: <img class="eq" src="eqs/581397984-130.png" alt="textup{OPT}(mathcal{U}) le delta" style="vertical-align: -5px" />.</p>
</li>
</ul>
<p>Note that the conjecture is false if <img class="eq" src="eqs/1463515723-130.png" alt="epsilon=0" style="vertical-align: -1px" />. Also, a random assignment satisfies <img class="eq" src="eqs/1727358876-130.png" alt="frac{1}{n}" style="vertical-align: -8px" /> fraction of edges and hence <img class="eq" src="eqs/73521339-130.png" alt="n ge frac{1}{delta}" style="vertical-align: -8px" />.</p>
<div id="footer">
<div id="footer-text">
Page generated 2015-08-13 19:25:58 India Standard Time, by <a href="http://jemdoc.jaboc.net/">jemdoc</a>.
</div>
</div>
</td>
</tr>
</table>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-56996692-1', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
